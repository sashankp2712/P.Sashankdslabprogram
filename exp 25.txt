#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 50
#define MAX_EDGES 100

struct Edge {
    int src, dest, weight;
};

int parent[MAX_VERTICES];
int num_vertices, num_edges;
struct Edge edges[MAX_EDGES];

int find(int i) {
    while (parent[i] != i) i = parent[i];
    return i;
}

void unite(int i, int j) {
    int root_i = find(i);
    int root_j = find(j);
    parent[root_i] = root_j;
}

void sortEdges() {
    for (int i = 0; i < num_edges - 1; i++) {
        for (int j = 0; j < num_edges - i - 1; j++) {
            if (edges[j].weight > edges[j + 1].weight) {
                struct Edge temp = edges[j];
                edges[j] = edges[j + 1];
                edges[j + 1] = temp;
            }
        }
    }
}

void kruskalMST() {
    int mst_weight = 0;
    int edge_count = 0;
    sortEdges();
    for (int i = 0; i < num_vertices; i++) {
        parent[i] = i;
    }
    printf("Following are the edges in the constructed MST\n");
    for (int i = 0; i < num_edges && edge_count < num_vertices - 1; i++) {
        int root_src = find(edges[i].src);
        int root_dest = find(edges[i].dest);
        if (root_src != root_dest) {
            unite(root_src, root_dest);
            printf("%d -- %d == %d\n", edges[i].src, edges[i].dest, edges[i].weight);
            mst_weight += edges[i].weight;
            edge_count++;
        }
    }
    printf("Minimum Cost Spanning Tree: %d\n", mst_weight);
}

int main() {
    num_vertices = 4;
    num_edges = 5;
    edges[0] = (struct Edge){0, 1, 10};
    edges[1] = (struct Edge){0, 2, 6};
    edges[2] = (struct Edge){0, 3, 5};
    edges[3] = (struct Edge){1, 3, 15};
    edges[4] = (struct Edge){2, 3, 4};
    kruskalMST();
    return 0;
}